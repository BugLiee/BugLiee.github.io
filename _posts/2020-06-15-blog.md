---
layout: post
title: 亲爱的Python老弟
categories: Python
description: 记录我和Python老弟的点点滴滴
keywords: Python
---

记录我和Python老弟的点点滴滴

### demo 之爬取小说 (注意各行缩进)
```
from android.app import Service
from android.os import IBinder
from android.content import Intent
from android.support.annotation import Nullable
from java import Override, static_proxy
from bs4 import BeautifulSoup
import requests
import os

class PBookService(static_proxy(Service)):
    @Nullable
    @Override(IBinder, [Intent])
    def onBind(self, intent):
        return null
    @Override(int, [Intent, int, int])
    def onStartCommand(self, intent, flags, startId):
        return Service.onStartCommand(self, intent, flags, startId)
 self.url = 'http://www.xbiquge.la/10/'
        self.names = []#存放章节名称
        self.hrefs = []#存放章节链接
        self.book = '10489'
        self.get_urlandname()
        self.path = "/sdcard/mypynovels"
        self.mkdir(self.path)
        for i in range(len(self.names)):
            name = self.names[i]
            text = str(self.get_text(self.hrefs[i]))
            os.chdir(self.path)
            print(os.getcwd())
            self.writer(name,"xs.txt",text)
  @Override(IBinder, [Intent])
    def onBind(self, intent):
        return null

        @Override(int,[Intent,int,int])
        def onStartCommand(self,intent,flags,startId):
            print("开始执行")
            self.url = 'http://www.xbiquge.la/10/'
            self.names = []#存放章节名称
            self.hrefs = []#存放章节链接
            self.book = '10489'
            self.get_urlandname()
            self.path = "/sdcard/mypynovels"
            self.mkdir(self.path)
            for i in range(len(self.names)):
                name = self.names[i]
                text = str(self.get_text(self.hrefs[i]))
                os.chdir(self.path)
                print(os.getcwd())
                self.writer(name,"xs.txt",text)
            return Service.onStartCommand(self,intent,flags.startId)

        def get_urlandname(self):
            response = requests.get(url=self.url + self.book )
            response.encoding='utf-8'
            req_parser = BeautifulSoup(response.text,"html.parser")
            dd = req_parser.find_all('dd')
            a_bf = BeautifulSoup(str(dd))
            a = a_bf.find_all('a')
            for i in a:
                self.names.append(i.string)#str只获取指定的文本类型
                self.hrefs.append(self.url + i['href'][4:])
            #print(self.names)
            #print(self.hrefs)
        def get_text(self,url):
            respons2 =requests.get(url=url)
            respons2.encoding='utf-8'
            c = BeautifulSoup(str(respons2.text),'html.parser')
            b = c.find_all('div', id='content')
            text = []
            for temp in  b:#获取标签里面的文本只能进行遍历每个满足条件的文本才能获取
                text.append(temp)
                txt = str(text)
            return txt.replace("<br/>","")[19:-179]
        def writer(self,name,path,text1):
            ''' 写入TXT文档'''
            with open(path,'a',encoding='utf-8') as f:
                f.write(name + '\n')#写入名字并换行
                f.writelines(text1)#追加内容
                f.write('\n\n')#换两行
        def mkdir(self,path):
            #去除首尾空格
            path = path.strip()
            # 去除尾部 \ 符号
            path = path.rstrip("\\")
            # 判断路径是否存在
            # 存在     True
            # 不存在   False
            isExists = os.path.exists(path)
            # 判断结果
            if not isExists:
                # 如果不存在则创建目录
                # 创建目录操作函数
                os.makedirs(path)
                print(path + ' 创建成功')
                return True
            else:
                # 如果目录存在则不创建，并提示目录已存在
                print(path + ' 目录已存在')
                return False
```
### 盘点 Python 的优缺点
　　Python是一种**面向对象、解释型**的**脚本语言**，同时也是一种功能强大而完善的通用型语言。<br>
   Java100行代码能干的事 也许Python只要20行。<br>
   
   + ***特点：***<br>
   　　1. 简单易学<br>
   　　Python是一种代表简单、注重思想的语言，阅读一个良好的Python程序应该让人像阅读英语段落。可以把Python看作是一种伪代码，我们注重于解决问题，而不是去研究语言本身。<br>
   　　2. 开源<br>
   　　Python是***FLOSS（自由/开源源码软件）***之一。<br>
   　　3. 高级语言<br>
   　　Python 是高级语言，因此当使用 Python 语言编写程序时，我们无需再考虑一些底层细节方面的问题。例如，如何管理程序使用的内存等等。<br>
   　　4. 解释型语言<br>
   　　一个用编译型语言（如 C 或 C++）写的程序，可以从源文件转换到一个计算机使用的语言。这个过程主要通过编译器完成。
   　　当运行程序的时候，我们可以把程序从硬盘复制到内存中并且运行。而 Python 语言写的程序，则不需要编译成二进制代码，可以直接从源代码运行程序。
   　　在计算机内部，由 Python 解释器把源代码转换成字节码的中间形式，然后再把它翻译成计算机使用的机器语言并运行。<br>
   　　5. 可移植性<br>
   　　由于 Python 是开源的，它已经被移植到许多平台上。如果能够避免使用依赖系统的特性，那就意味着，所有 Python 程序都无需修改就可以在好多平台上运行，
   　　包括 Linux 、Windows、FreeBSD、          Solaris 等等，甚至还有 PocketPC、Symbian 以及 Google 基于 Linux 开发的 Android 平台。
   　　解释型语言几乎天生就是跨平台的。Python 作为一门解释型的语言，它天生具有跨平台的特征，只要为平台提供了相应的 Python 解释器，Python 就可以在该平台上运行。<br>
   　　6. 面向对象<br>
   　　程序是由数据和功能组合而成的对象构建起来的。<br>
   　　***在面向过程的语言中，程序由函数构建而成。*** <br>
   　　7. 强大的功能<br>
   　　Python 强大的功能也许才是很多用户支持 Python 的最重要的原因，从字符串处理到复杂的 3D 图形编程，Python 借助扩展模块都可以轻松完成。<br>
   　　8. 可扩展性<br>
   　　Pyth</font>on 的可扩展性体现为它的模块，Python 具有脚本语言中最丰富和强大的类库，这些类库覆盖了文件 I/O、GUI、网络编程、数据库访问、文本操作等绝大部分应用场景。
   　　Python 可扩展性一个最好的体现是，当我们需要一段关键代码运行的更快时，可以将其用 C 或 C++ 语言编写，然后在 Python 程序中使用它们即可。<br>
   + ***缺点：***<br>
   　　1. 速度慢：<br>
   　　Python 程序比 Java、C、C++ 等程序的运行效率都要慢。<br>
   　　2. 源代码加密困难：<br>
   　　不像编译型语言的源程序会被编译成目标程序，Python 直接运行源程序，因此对源代码加密比较困难。<br>
     
### Python 安装与使用

   + ***Unix下***<br>
   　　直接安装即可，apt-get install python3.8<br>
   　　一般安装之后不需要其他配置，如果在终端无法运行Python解释器，可以配置Python安装路径到环境。 <br>
   + ***Windows下***<br>
   　　进入Python官网 http://www.python.org ，在“Downloads” 下拉菜单中选择相应的操作系统，我们选择windows。<br>
   　　运行下载的.exe可执行文件安装Python，如果无法在cmd终端运行，同样需要配置环境变量。

### 终端执行传参

```
如果可能的话，解释器会读取命令行参数，转化为字符串列表存入 sys 模块中的 argv 变量中。
执行命令 import sys 你可以导入这个模块并访问这个列表。这个列表最少也会有一个元素；
如果没有给定输入参数，sys.argv[0] 就是个空字符串。如果脚本名是 '-'``（标准输入）时，
``sys.argv[0] 就是 '-'。使用 -c 命令 时，sys.argv[0] 就会是 '-c'。
如果使用选项 -m module，sys.argv[0] 就是包含目录的模块全名。
在 -c command 或 -m module 之后的选项不会被解释器处理，而会直接留在 sys.argv 中给命令或模块来处理。
```


### 交互模式

　　在终端（tty）输入并执行指令时，我们说解释器是运行在 交互模式（interactive mode）。<br>
　　在这种模式中，它会显示 主提示符（primary prompt），提示输入下一条指令，通常用三个大于号（>>>）表示；<br>
　　连续输入行的时候，它会显示 次要提示符，默认是三个点（...）。<br>
　　进入解释器时，它会先显示欢迎信息、版本信息、版权声明，然后就会出现提示符：<br>
   

```
$ python3.8
Python 3.8 (default, Sep 16 2015, 09:25:04)
[GCC 4.8.2] on linux
Type "help", "copyright", "credits" or "license" for more information.
>>>
```
**多行指令需要在连续的多行中输入。比如，以 if 为例：**
```
>>> the_world_is_flat = True
>>> if the_world_is_flat:
...     print("Be careful not to fall off!")
...
Be careful not to fall off!
```
